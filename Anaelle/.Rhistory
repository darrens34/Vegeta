p <-fviz_add(p, ind.sup.coord, color ="blue")
p
fviz_pca_biplot(p, repel = TRUE)
fviz_pca_biplot(p, repel = TRUE)
fviz_pca_biplot(res_pca, repel = TRUE)
p <-fviz_add(p, ind.sup.coord, color ="blue")
p
fviz_pca_biplot(res_pca, repel = TRUE)+
fviz_add( ind.sup.coord, color ="blue")
p <-fviz_pca_biplot(res_pca, repel = TRUE)
p <-fviz_add(p, ind.sup.coord, color ="blue")
p
load("F:/MIASHS/UEs/ACP/clash_dataset.RData")
head(clash_dataset)
View(clash_dataset)
library(FactoMineR)
library(factoextra) # pour les graphes
library(tidyverse)
library(dplyr)
clash_dataset %>%
replace_na(list(Count = 1)) -> clash_dataset
library(tidyr)
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
clash_dataset %>%
replace_na(list(Count = 1)) -> clash_dataset
View(clash_dataset)
mystandardisation <- function(x) {
(x -mean(x)) / sd(x)
}
# dplyr::mutate_if is used to apply the fonction only on numeric (quantitatives) variables
clash_dataset %>%
mutate_if(.predicate = is.numeric, mystandardisation) -> clash_dataset_preproc
# to retrieve indivudual Names on FactoMineR outputs
row.names(clash_dataset_preproc) <- clash_dataset$Name
head(clash_dataset_preproc)
head(clash_dataset)
clash_dataset$Name
?FactoMineR
?ACP
?PCA
cost_idx <- which(colnames(clash_dataset_preproc %>% select_if(is.numeric)) == "Cost")
cost_idx
clash_dataset_preproc %>% select_if(is.numeric))
clash_dataset_preproc %>% select_if(is.numeric)
?fviz_screeplot
fviz_screeplot(res_pca_quantisup, ncp=10)
res_pca_quantisup<- PCA(clash_dataset_preproc, scale.unit = FALSE, graph = F, quanti.sup=cost_idx)
res_pca_quantisup<- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, quanti.sup=cost_idx)
fviz_screeplot(res_pca_quantisup, ncp=10)
fviz_pca_var(res_pca_quantisup, axes=c(1,2), repel = TRUE)
fviz_pca_ind(res_pca_quantisup, repel = TRUE)
fviz_pca_biplot(res_pca_quantisup, repel = TRUE)
fviz_contrib(res_pca_quantisup, choice = "ind", axes = 1)
fviz_contrib(res_pca_quantisup, choice = "var", axes = 1)
u
fviz_pca_var(res_pca_quantisup, axes=c(1,2), repel = TRUE)
nrows(res_pca_quantisup)
nrow(res_pca_quantisup)
res_pca_quantisup
dim(res_pca_quantisup)
View(res_pca_quantisup)
nrow(clash_dataset)
plot(res_pca_quantisup)
plot(res_pca_quantisup, choix = "var", axes = c(1,2))
fviz_screeplot(res_pca_quantisup, ncp=10)
clash_dataset_qualisup <- clash_dataset_preproc[,6:17]
clash_dataset_qualisup
clash_dataset_qualisup <- clash_dataset_preproc[,6:17]
res_pca_qualisup <- PCA(clash_dataset_qualisup, scale.unit = FALSE, graph = F, quali.sup=1)
fviz_pca_ind(res_pca_qualisup, repel = TRUE,axes = c(1,2), habillage=1)
fviz_pca_ind(res_pca_qualisup, repel = TRUE,axes = c(1,2), habillage=1,addEllipses=TRUE)
?fviz_pca_ind
res_pca_indsup <- PCA(clash_dataset_preproc, scale.unit = FALSE, graph = F, ind.sup=c(dragon_idx,giant_idx))
fviz_pca_ind(res_pca_indsup, repel = TRUE,axes = c(1,2))
res_pca_indsup <- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, ind.sup=c(dragon_idx,giant_idx))
dragon_idx <- which(clash_dataset_preproc$Name == "Inferno Dragon")
giant_idx <- which(clash_dataset_preproc$Name == "Giant")
res_pca_indsup <- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, ind.sup=c(dragon_idx,giant_idx))
fviz_pca_ind(res_pca_indsup, repel = TRUE,axes = c(1,2))
#1
cost_idx <- which(colnames(clash_dataset_preproc %>% select_if(is.numeric)) == "Cost")
res_pca_quantisup<- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, quanti.sup=cost_idx)
fviz_pca_var(res_pca_quantisup, axes=c(1,2), repel = TRUE)
load("F:/MIASHS/UEs/ACP/clash_dataset.RData")
mystandardisation <- function(x) {
(x -mean(x)) / sd(x)
}
# dplyr::mutate_if is used to apply the fonction only on numeric (quantitatives) variables
clash_dataset %>%
mutate_if(.predicate = is.numeric, mystandardisation) -> clash_dataset_preproc
# to retrieve indivudual Names on FactoMineR outputs
row.names(clash_dataset_preproc) <- clash_dataset$Name
head(clash_dataset_preproc)
res_pca_indsup <- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, ind.sup=c(dragon_idx,giant_idx))
dragon_idx <- which(clash_dataset_preproc$Name == "Inferno Dragon")
giant_idx <- which(clash_dataset_preproc$Name == "Giant")
clash_dataset %>%
replace_na(list(Count = 1)) -> clash_dataset
# dplyr::mutate_if is used to apply the fonction only on numeric (quantitatives) variables
clash_dataset %>%
mutate_if(.predicate = is.numeric, mystandardisation) -> clash_dataset_preproc
# to retrieve indivudual Names on FactoMineR outputs
dragon_idx <- which(clash_dataset_preproc$Name == "Inferno Dragon")
giant_idx <- which(clash_dataset_preproc$Name == "Giant")
res_pca_indsup <- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, ind.sup=c(dragon_idx,giant_idx))
fviz_pca_ind(res_pca_indsup, repel = TRUE,axes = c(1,2))
row.names(clash_dataset_preproc) <- clash_dataset$Name
res_pca_indsup <- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, ind.sup=c(dragon_idx,giant_idx))
fviz_pca_ind(res_pca_indsup, repel = TRUE,axes = c(1,2))
cost_idx <- which(colnames(clash_dataset_preproc %>% select_if(is.numeric)) == "Cost")
res_pca_quantisup<- PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F, quanti.sup=cost_idx)
fviz_pca_var(res_pca_quantisup, axes=c(1,2), repel = TRUE)
fviz_pca_biplot(res_pca)
res_pca <-PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F)
fviz_pca_biplot(res_pca)
fviz_pca_biplot(res_pca,repel=TRUE)
fviz_screeplot(res_pca, ncp=10)
res_pca$eig
res_pca <-PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F)
fviz_screeplot(res_pca, ncp=10)
res_pca$eig
res_pca$var$contrib
fviz_contrib(res_pca, choice = "var", axes = 1)
fviz_contrib(res_pca, choice = "ind", axes = 2)
res_pca$ind$contrib
?order
order(res_pca$ind$contrib[," Dim.2"])
order(res_pca$ind$contrib[,"Dim.2"])
res_pca$ind$contrib [order(res_pca$ind$contrib[,"Dim.2"]),]
res_pca$ind$contrib [order(res_pca$ind$contrib[,"Dim.2"],decreasing = TRUE),]
fviz_pca_ind(res_pca, repel = TRUE)
fviz_pca_biplot(res_pca, repel = TRUE)
fviz_pca_ind(res_pca_qualisup, repel = TRUE,axes = c(1,2), habillage=1,addEllipses=TRUE)
fviz_contrib(res_pca, choice = "ind", axes = 2)
?fviz_pca_biplot
fviz_pca_biplot(res_pca, repel = TRUE,axes = c(1,3))
fviz_pca_biplot(res_pca, repel = TRUE)
fviz_pca_biplot(res_pca, repel = TRUE,axes = c(1,3))
fviz_contrib(res_pca, choice = "var", axes = 1)
fviz_pca_biplot(res_pca, repel = TRUE,axes = c(1,2))
###################### importation librairies
library(FactoMineR)
library(factoextra) # pour les graphes
###################### importation des données
# load dataset
data(decathlon)
# view
decathlon
# résumé
summary(decathlon)
?sample.int
head(decathlon)
1:nrow(decathlon)
sample.int(n = 1:nrow(decathlon) , size = 10 , replace = F)
sample.int(n = 10 , size = 1:nrow(decathlon), replace = F)
sample.int(n = nrow(decathlon) , size = 10, replace = F)
nrow(decathlon)
nrow(decathlon) /3
nrow(decathlon)
nrow(decathlon) /3
sample.int(n = nrow(decathlon) , size =  nrow(decathlon) /3, replace = F)
sample <- sample.int(n = nrow(decathlon) , size =  nrow(decathlon) /3, replace = F)
sample <- sample.int(n = nrow(decathlon) , size =  nrow(decathlon) /3, replace = F)
train <- decathlon[-sample,]
test  <- decathlon[sample,]
train
test
nrow(decathlon) *80/100
sample <- sample.int(n = nrow(decathlon) , size =  nrow(decathlon) *80/100, replace = F)
train <- decathlon[sample,]
test  <- decathlon[-sample,]
sample
dim(train)
dim(test)
res_pca <- PCA(train, scale.unit = TRUE, graph = F )
###################### importation des données
# load dataset
data(decathlon)
# view
decathlon
# résumé
summary(decathlon)
###################### Exercice 1
# Pourquoi est-il important de décomposer notre base d’apprentissage avant de réaliser l’ACP et la régression ?
# Pour avoir un jeu d'apprentissage et de test
# Quel problème cela va-t-il engendrer pour l’étape de standardisation ?
# avoir même moyenne et ecart type entre les 2 jeux de données
# sample
sample <- sample.int(n = nrow(decathlon) , size =  nrow(decathlon) *80/100, replace = F)
train <- decathlon[sample,]
test  <- decathlon[-sample,]
res_pca <- PCA(train, scale.unit = TRUE, graph = F )
head(decathlon)
res_pca <- PCA( train[,1:10], ncp = 5, scale.unit = TRUE, graph=FALSE)
res_pca_train <- PCA( train[,1:10], ncp = 5, scale.unit = TRUE, graph=FALSE)
res_pca_train <- PCA( train[,1:10], ncp = 5, scale.unit = TRUE, graph=FALSE)
fviz_pca_biplot(res_pca_train)
res_pca_train$ind
train_proj <- res_pca_train$ind$coord
res_pca_train$svd
?PCA
test_standard <- test
test_standard
res_pca$call$centre
test[,1:10]
t(apply(test[,1:10], MARGIN = 1, FUN = function(x) { (x-res_pca$call$centre)/res_pca$call$ecart.type } ))
res_pca$call$centre
7.30 - 7.267188
res_pca$call$ecart.type
7.30 - 7.267188
7.30 - 7.267188)(/0.30266766
(7.30 - 7.267188)/0.30266766
test_standard[, 1:10] <- t(apply(test[,1:10], MARGIN = 1, FUN = function(x) { (x-res_pca$call$centre)/res_pca$call$ecart.type } ))
test_standard
res_pca_train$svd$V
fviz_pca_biplot(res_pca_train)
fviz_pca_var(res_pca_train)
res_pca_train$var$contrib
fviz_contrib(res_pca_train, choice = "var", axes = 1)
res_pca_train$var
fviz_pca_biplot$eig
res_pca_train$eig
test_standard
res_pca_train$svd$V
res_pca_train$svd$V[,1:2]
test_proj <- test_standard[, 1:10] %*% res_pca_train$svd$V[,1:2]
test_standard[, 1:10]
class(test_standard[, 1:10] )
class( res_pca_train$svd$V[,1:2])
as.matrix(test_standard[, 1:10])
test_proj <- as.matrix(test_standard[, 1:10]) %*% res_pca_train$svd$V[,1:2]
test_proj
fviz_pca_ind(res_pca_train)
train_proj
test_proj
fviz_pca_ind(train_proj)
plot(train_proj)
plot(train_proj,pch=21,col="black")
plot(train_proj,pch=19,col="black")
plot(train_proj,pch=19,col="black");points(test_proj,pch=19,col="red")
train_proj
test_proj
train_proj <- as.data.frame(train_proj)
train_proj <- as.data.frame(train_proj)[,1:2]
train_proj
test_proj <- as.data.frame(test_proj)
train$Points
train_proj$Points <- train$Points
test_proj$Points <- test$Points
test_proj
colnames(train_proj)
colnames(test_proj)
colnames(test_proj) <- colnames(train_proj)
model_pcr <- lm(Points~Dim.1+Dim.2,data = train_proj)
summary(model_pcr)
?predict
test_proj
test_proj[,1:2]
predict(model_pcr,test_proj[,1:2])
predict_pcr
predict_pcr <- predict(model_pcr,test_proj[,1:2])
predict_pcr
test_standard[, 1:10]
res_pca_train$svd$V[,1:2]
as.matrix(test_standard[, 1:10])
res_pca_train$svd$V
as.matrix(test_standard[, 1:10]) %*% res_pca_train$svd$V[,1:2]
as.matrix(test_standard[, 1:10]) %*% res_pca_train$svd$V
train_proj
data(decathlon)
# view
decathlon
# résumé
summary(decathlon)
###################### Exercice 1
# Pourquoi est-il important de décomposer notre base d’apprentissage avant de réaliser l’ACP et la régression ?
# Pour avoir un jeu d'apprentissage et de test
# Quel problème cela va-t-il engendrer pour l’étape de standardisation ?
# avoir même moyenne et ecart type entre les 2 jeux de données
# sample
sample <- sample.int(n = nrow(decathlon) , size =  nrow(decathlon) *80/100, replace = F)
train <- decathlon[sample,]
test  <- decathlon[-sample,]
res_pca_train <- PCA( train[,1:10], ncp = 5, scale.unit = TRUE, graph=FALSE)
fviz_pca_biplot(res_pca_train)
res_pca_train$eig
train_proj <- res_pca_train$ind$coord
# projeter données test
test_standard <- test
res_pca$call$centre # moyenne pour train
res_pca$call$ecart.type  # e-t pour train
# standardisation
test_standard[, 1:10] <- t(apply(test[,1:10], MARGIN = 1, FUN = function(x) { (x-res_pca$call$centre)/res_pca$call$ecart.type } ))
# projection (matrix multiplication between individuals and dimensions coordinates)
test_proj <- as.matrix(test_standard[, 1:10]) %*% res_pca_train$svd$V
test_proj
train_proj
plot(train_proj,pch=19,col="black")
points(test_proj,pch=19,col="red")
# convert to dataframe
train_proj <- as.data.frame(train_proj)[,1:2]
test_proj <- as.data.frame(test_proj)
# add target column
train_proj$Points <- train$Points
test_proj$Points <- test$Points
# rename variables to work with predict function
colnames(test_proj) <- colnames(train_proj)
# fit
model_pcr <- lm(Points~Dim.1+Dim.2,data = train_proj)
# summary
summary(model_pcr)
test_proj[,1:2]
predict_pcr <- predict(model_pcr,test_proj[,1:2])
test_proj$Points
predict_pcr
test_proj
train_proj
train_proj
train$Points
test_proj
train_proj
?predict
predict_pcr <- predict.lm(model_pcr,test_proj[,1:2])
predict_pcr
test_proj$Points
test_proj
test_proj
###################### Exercice 2 - PCR
# convert to dataframe
train_proj <- as.data.frame(train_proj)[,1:2]
test_proj <- as.data.frame(test_proj)
# add target column
train_proj$Points <- train$Points
test_proj$Points <- test$Points
# rename variables to work with predict function
colnames(test_proj) <- colnames(train_proj)
# fit
model_pcr <- lm(Points~Dim.1+Dim.2,data = train_proj)
# summary
summary(model_pcr)
test_proj$Points
(test_proj$Points - predict_pcr)^2
test_proj$Points - predict_pcr
(test_proj$Points - predict_pcr)^2
sum((test_proj$Points - predict_pcr)^2))
predict_pcr
length(predict_pcr)
sqrt(sum((test_proj$Points - predict_pcr)^2)/length(predict_pcr))
plot(x = test_proj$Points, y = predict_pcr)
plot(x = test_proj$Points, y = predict_pcr,xlab="measured",ylab="fit")
abline(a=0,b=1)
plot(x = test_proj$Points, y = predict_pcr,xlab="measured",ylab="fit",xlim=c(7400,8300),ylim=c(7400,8300))
abline(a=0,b=1)
abline(a=0,b=1,col="red",lyt="dashed")
abline(a=0,b=1,col="red",lty="dashed")
plot(x = test_proj$Points, y = predict_pcr,xlab="measured",ylab="fit",xlim=c(7400,8300),ylim=c(7400,8300))
abline(a=0,b=1,col="red",lty="dashed")
?abline
?par
abline(a=0,b=1,col="red",lty="dashed")
plot(x = test_proj$Points, y = predict_pcr,xlab="measured",ylab="fit",xlim=c(7400,8300),ylim=c(7400,8300),pch=19)
abline(a=0,b=1,col="red",lty="dashed")
load("F:/MIASHS/UEs/ACP/clash_dataset.RData")
head(clash_dataset)
View(clash_dataset)
library(FactoMineR)
library(factoextra) # pour les graphes
library(tidyverse)
library(dplyr)
library(tidyr)
#############################
## Exercice 1
############################
# Gerer les valeurs manquantes?
# Supprimer les lignes
# Remplacer par la valeur moyenne de la colonne ou par la valeur la plus représentée
clash_dataset %>%
replace_na(list(Count = 1)) -> clash_dataset
#############################
## Exercice 2
############################
mystandardisation <- function(x) {
(x -mean(x)) / sd(x)
}
# dplyr::mutate_if is used to apply the fonction only on numeric (quantitatives) variables
clash_dataset %>%
mutate_if(.predicate = is.numeric, mystandardisation) -> clash_dataset_preproc
# to retrieve indivudual Names on FactoMineR outputs
row.names(clash_dataset_preproc) <- clash_dataset$Name
head(clash_dataset_preproc)
#Nous avons vu dans le TP1 que FactoMineR est capable de lui aussi standardiser les variables via son option scale=TRUE.
# À votre avis, à quel effet doit on s’attendre entre notre jeu de données standardisé clash_dataset_preproc
#et le jeu de données non-standardisé, si on applique également la standardisation de FactoMineR ?
# Je ne sais pas si PCA centre / norm. A priori normalise avec la variance et pas avec l'ecart type
#############################
## Exercice 3
############################
# Damage corrélés + entre eux
# Min max fortement corrélés
# Hitpoints corrélés + à cost
# Analyse limitée car on ne voit plus rien si beaucoup de variables
#############################
## Exercice 4
############################
res_pca <-PCA(clash_dataset_preproc %>% select_if(is.numeric), scale.unit = FALSE, graph = F)
fviz_screeplot(res_pca, ncp=10)
res_pca$eig
res_pca$var$contrib
fviz_contrib(res_pca, choice = "var", axes = 1)
res_pca$var$contrib
fviz_screeplot(res_pca, ncp=10)
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
fviz_contrib(res_pca, choice = "ind", axes = 2)
res_pca$ind$contrib [order(res_pca$ind$contrib[,"Dim.2"],decreasing = TRUE),]
fviz_pca_ind(res_pca, repel = TRUE)
fviz_pca_biplot(res_pca, repel = TRUE)
fviz_pca_biplot(res_pca, repel = TRUE,axes = c(1,3))
########## Importer les librairies
library(FactoMineR)
library(factoextra) # pour les graphes
library(tidyverse)
library(dplyr)
library(tidyr)
######### ######### #########
######### importer et transformer les données
######### ######### #########
############# Importer les données
path<-"F:/MIASHS/TER/Vegeta/data/data_sans_NA/Puechabon_2010_vpd.csv"
donnees_base <- read.table(path,sep=",",dec=".",header=T,na.strings = c("-9999","NA"))
head(donnees_base)
setwd("F:/MIASHS/TER/Vegeta/Anaelle")
summary(donnees_base)
donnees_base = donnees_base[,-1]# supprime premier colonne d'index
donnees_base = donnees_base[,-which(colnames(donnees_base)=="TS_2")]
donnees_base = donnees_base[,-which(colnames(donnees_base)=="TS_3")] # Enleve TS_2 et TS_3 car correles a TS
#############  Transforme les dates
donnees_base$dates = strptime(donnees_base$date,format = "%Y-%m-%d %H:%M:%S")
donnees_base$heure_solaire = strptime(donnees_base$heure_solaire,format = "%H:%M")
#############  Supprime colonnes inutiles pour le moment
donnees<- donnees_base[,-which(names(donnees_base) %in% c("TIMESTAMP_START","TIMESTAMP_END","DTime","dates","heure_solaire"))]
# On enlève PRI car on a pas de mesure la nuit! Pas possible de prédire avec les NA ensuite :(
donnees = donnees[,-which(colnames(donnees)=="PRI")]
############ ACP
res_pca<- PCA(donnees, scale.unit = TRUE, graph = F)
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
fviz_screeplot(res_pca, ncp=10)
res_pca$eig
fviz_screeplot(res_pca)
res_pca$eig
######### ######### #########
######### importer et transformer les données
######### ######### #########
############# Importer les données
path<-"F:/MIASHS/TER/Vegeta/data/data_sans_NA/Puechabon_2010_vpd.csv"
donnees_base <- read.table(path,sep=",",dec=".",header=T,na.strings = c("-9999","NA"))
head(donnees_base)
setwd("F:/MIASHS/TER/Vegeta/Anaelle")
summary(donnees_base)
donnees_base = donnees_base[,-1]# supprime premier colonne d'index
donnees_base = donnees_base[,-which(colnames(donnees_base)=="TS_2")]
donnees_base = donnees_base[,-which(colnames(donnees_base)=="TS_3")] # Enleve TS_2 et TS_3 car correles a TS
#############  Transforme les dates
donnees_base$dates = strptime(donnees_base$date,format = "%Y-%m-%d %H:%M:%S")
donnees_base$heure_solaire = strptime(donnees_base$heure_solaire,format = "%H:%M")
#############  Supprime colonnes inutiles pour le moment
donnees<- donnees_base[,-which(names(donnees_base) %in% c("TIMESTAMP_START","TIMESTAMP_END","DTime","dates","heure_solaire"))]
# On enlève PRI car on a pas de mesure la nuit! Pas possible de prédire avec les NA ensuite :(
donnees = donnees[,-which(colnames(donnees)=="PRI")]
######### ######### #########
######### Regarde les correlations entre variables
######### ######### #########
core <- cor(donnees,method="pearson",use = "pairwise.complete.obs")
#write.csv(core,"correlations_entre_variables.csv")
#############  Supprime colonnes corrélées
donnees<- donnees[,-which(names(donnees) %in% c("NETRAD","PPFD_DIF"	,"PPFD_OUT"	,"SW_IN","SW_OUT"	,"H","LE","RH","TA","TAU","USTAR","G"))]
path<-"F:/MIASHS/TER/Vegeta/data/data_post_modelisation/Puechabon_2010_post_model.csv"
donnees_base <- read.table(path,sep=",",dec=".",header=T,na.strings = c("-9999","NA"))
head(donnees_base)
summary(donnees_base)
setwd("F:/MIASHS/TER/Vegeta/Anaelle")
res_pca<- PCA(donnees, scale.unit = TRUE, graph = F)
fviz_screeplot(res_pca)
res_pca$eig
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
donnees_base<-donnees_base[,-1]
summary(donnees_base)
path<-"F:/MIASHS/TER/Vegeta/data/data_post_modelisation/Puechabon_2010_post_model.csv"
donnees_base <- read.table(path,sep=",",dec=".",header=T,na.strings = c("-9999","NA"))
head(donnees_base)
setwd("F:/MIASHS/TER/Vegeta/Anaelle")
summary(donnees_base)
donnees_base<-donnees_base[,c(-1,3,4)]
donnees_base<-donnees_base[,-c(1,3,4)]
dim(donnees_base)
res_pca<- PCA(donnees, scale.unit = TRUE, graph = F)
fviz_screeplot(res_pca)
res_pca$eig
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
head(donnees_base)
res_pca<- PCA(donnees_base, scale.unit = TRUE, graph = F)
fviz_screeplot(res_pca)
res_pca$eig
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
res_pca<- PCA(donnees_base, scale.unit = TRUE, graph = F,quanti.sup=1)
fviz_screeplot(res_pca)
res_pca$eig
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
head(donnees_base)
res_pca$var$contrib
fviz_pca_var(res_pca, axes=c(1,3), repel = TRUE)
res_pca$eig
fviz_pca_var(res_pca, axes=c(1,2), repel = TRUE)
