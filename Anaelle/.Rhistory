library(leaps)
?regsubsets
########## Importer les librairies
library(leaps)
?regsubsets
######### ######### #########
######### importer et transformer les données
######### ######### #########
############# Importer les données
path<-"F:/MIASHS/TER/Vegeta/data/data_sans_NA/Puechabon_2010_vpd.csv"
donnees_base <- read.table(path,sep=",",dec=".",header=T,na.strings = c("-9999","NA"))
head(donnees_base)
setwd("F:/MIASHS/TER/Vegeta/Anaelle")
summary(donnees_base)
donnees_base = donnees_base[,-1]# supprime premier colonne d'index
donnees_base = donnees_base[,-which(colnames(donnees_base)=="TS_2")]
donnees_base = donnees_base[,-which(colnames(donnees_base)=="TS_3")] # Enleve TS_2 et TS_3 car correles a TS
#############  Transforme les dates
donnees_base$dates = strptime(donnees_base$date,format = "%Y-%m-%d %H:%M:%S")
donnees_base$heure_solaire = strptime(donnees_base$heure_solaire,format = "%H:%M")
#############  Supprime colonnes inutiles pour le moment
donnees<- donnees_base[,-which(names(donnees_base) %in% c("TIMESTAMP_START","TIMESTAMP_END","DTime","dates","heure_solaire"))]
# On enlève PRI car on a pas de mesure la nuit! Pas possible de prédire avec les NA ensuite :(
donnees = donnees[,-which(colnames(donnees)=="PRI")]
######### ######### #########
######### Regarde les correlations entre variables
######### ######### #########
core <- cor(donnees,method="pearson",use = "pairwise.complete.obs")
#write.csv(core,"correlations_entre_variables.csv")
#############  Supprime colonnes corrélées
donnees<- donnees[,-which(names(donnees) %in% c("NETRAD","PPFD_DIF"	,"PPFD_OUT"	,"SW_IN","SW_OUT"	,"H","LE","RH","TA","TAU","USTAR","G"))]
######### ######### #########
######### Recherche des variables au différents temps
######### ######### #########
######### Selection du meilleur modele au temps t
mod1 = regsubsets(SAP_FLOW ~  P+ PA  +PPFD_IN + TS + WD+WS+ CO2 +  FC  + H2O  + SB + SC +SH  +SLE+ZL   + VPD,
data = donnees,method = "exhaustive",nvmax=ncol(donnees)-1) # 28 est le nombre total de variable
plot(mod1, scale = "bic")
obj_mod1 = summary(mod1)
res_mod1 = obj_mod1$which[which.min(obj_mod1$bic),]*1
sum(res_mod1) # nb de variables retenues
res_mod1
liste_variable = c("P", "PA", "PPFD_IN"  , "TS" , "WD" , "WS" , "CO2" , "FC" ,  "H2O" , "SB" , "SC" , "SH" ,"SLE","ZL", "VPD")
liste_decalage = c("donnees", "donnees_30","donnees_1h","donnees_1h30","donnees_2h","donnees_2h30","donnees_3h")
decalage = list()
variable = list()
compt = 0
for( i in c(liste_variable))
{
res_bic = list()
for(les_donnees in liste_decalage )
{
res_bic = c(res_bic, BIC(lm(SAP_FLOW~get(i),data = get(les_donnees))))
}
compt = compt + 1
decalage[compt] = liste_decalage[which.min(res_bic)]
variable[compt] = i
}
cbind(decalage,variable)
