##### 1
path<-"F:/MIASHS/UEs/base_stat/SautHauteur.csv"
donnees <- read.csv(path,sep=";",dec=",",header=T)
donnees
##### 2
plot(donnees)
# Cette commande effectue des plots entre les variables deux à deux.
# Elle permet de mettre rapidement en évidence des corrélations entre certaines variables.
# On observe une corrélation positive entre la taille et la performance.
# On observe pas de corrélation entre la taille et le poids, ni entre la performance et le poids.
##### 3
# Je propose d'utiliser la taille de l'individu pour prédire les performances de saut en hauteur.
##### 4
plot(Perf~Taille,data=donnees,xlab="Taille de l'individu (m)",ylab="Performance (m)")
##### 5
Perf_moy<-mean # Moyenne des performances
Perf_sd<-sd(donnees$Perf) # Ecart type des performances
Taille_moy<-mean(donnees$Taille) # Moyenne des tailles
Taille_sd<-sd(donnees$Taille) #
cov_formule <-sum((donnees$Taille - mean(donnees$Taille))*(donnees$Perf - mean(donnees$Perf)))/lenght(donnees$Taille)
cov_formule <-sum((donnees$Taille - mean(donnees$Taille))*(donnees$Perf - mean(donnees$Perf)))/length(donnees$Taille)
cov_fct<-cov(x=donnees$Taille,y=donnees$Perf)
cov_formule
cov_fct
coef_cor<-cov_formule / sqrt(sum((donnees$Taille - mean(donnees$Taille))^2) * sum((donnees$Perf - mean(donnees$Perf))^2))
coef_cor
cor(x=donnees$Taille,y=donnees$Perf)
coef_cor<-cov_formule / (var(donnees$Taille)*var(donnees$Perf))
coef_cor
cov_formule
coef_cor<-cov_formule / (Taille_sd*Perf_sd)
coef_cor
coef_cor_R<-cor(x=donnees$Taille,y=donnees$Perf)
coef_cor_R
test<-cor.test(x=donnees$Taille,y=donnees$Perf)
test
lm(donnees$Perfdonnees$Taille)
lm(donnees$Perf~donnees$Taille)
reg<-lm(donnees$Perf~donnees$Taille)
summary(reg)
help(summary)
coef_cor_R*coef_cor_R
reg$coefficients[1]
reg$coefficients[2]
2.93* 2 - 3.59
##### 1
path<-"F:/MIASHS/UEs/base_stat/SautHauteur.csv"
donnees <- read.csv(path,sep=";",dec=",",header=T)
donnees
##### 2
plot(donnees)
# Cette commande effectue des plots entre les variables deux à deux.
# Elle permet de mettre rapidement en évidence des corrélations entre certaines variables.
# On observe une corrélation positive entre la taille et la performance.
# On n'observe pas de corrélation entre la taille et le poids, ni entre la performance et le poids.
##### 3
# Je propose d'utiliser la taille de l'individu pour prédire les performances de saut en hauteur.
##### 4
plot(Perf~Taille,data=donnees,xlab="Taille de l'individu (m)",ylab="Performance (m)")
Perf_moy<-mean # Moyenne des performances
Perf_sd<-sd(donnees$Perf) # Ecart type des performances
Taille_moy<-mean(donnees$Taille) # Moyenne des tailles
Taille_sd<-sd(donnees$Taille) # Ecart type des tailles
Taille_sd
Perf_moy
Perf_sd
Taille_moy
Perf_moy<-mean(donnees$Perf) # Moyenne des performances =
Perf_moy
Perf_sd
Taille_moy
Taille_sd
cov_formule <-sum((donnees$Taille - mean(donnees$Taille))*(donnees$Perf - mean(donnees$Perf)))/length(donnees$Taille)
cov_fct<-cov(x=donnees$Taille,y=donnees$Perf)
cov_formule
cov_fct<-cov(x=donnees$Taille,y=donnees$Perf)
cov_fct
cov_formule <-(sum((donnees$Taille - mean(donnees$Taille))*(donnees$Perf - mean(donnees$Perf))))/length(donnees$Taille)
cov_formule
coef_cor<-cov_formule / (Taille_sd*Perf_sd)
coef_cor
coef_cor_R<-cor(x=donnees$Taille,y=donnees$Perf)
coef_cor_R
shapiro.test(donnees$Taille)
?shapiro.test
shapiro.test(donnees$Perf) # pvalue = 0.9789 : On ne rejette pas H0, les données sont issues d'une population normalement distribuée
donnees
(sum(donnees$Taille*donnees$Perf)-((sum(donnees$Taille)*sum(donnees$Perf))/length(donnees$Taille)))/(sqrt((sum(donnees$Taille^2)-((sum(donnees$Taille)^2)/length(donnees$Taille)))*(sum(donnees$Perf^2)-((sum(donnees$Perf)^2)/length(donnees$Perf)))))
coef_cor<-(sum(donnees$Taille*donnees$Perf)-((sum(donnees$Taille)*sum(donnees$Perf))/length(donnees$Taille)))/(sqrt((sum(donnees$Taille^2)-((sum(donnees$Taille)^2)/length(donnees$Taille)))*(sum(donnees$Perf^2)-((sum(donnees$Perf)^2)/length(donnees$Perf)))))
coef_cor
n<-length(donnees$Taille)
coef_cor<-(sum(donnees$Taille*donnees$Perf)-((sum(donnees$Taille)*sum(donnees$Perf))/n))/
sqrt((sum(donnees$Taille^2)-((sum(donnees$Taille)^2)/n))*(sum(donnees$Perf^2)-((sum(donnees$Perf)^2)/n)))
coef_cor
N<-length(donnees$Taille)
cov_formule <-(sum((donnees$Taille - Taille_moy)*(donnees$Perf - Perf_moy)))/N
cov_formule
coef_cor<-(sum(donnees$Taille*donnees$Perf)-((sum(donnees$Taille)*sum(donnees$Perf))/N))/
sqrt((sum(donnees$Taille^2)-((sum(donnees$Taille)^2)/N))*(sum(donnees$Perf^2)-((sum(donnees$Perf)^2)/N)))
coef_cor_R<-cor(x=donnees$Taille,y=donnees$Perf)
coef_cor
coef_cor_R<-cor(x=donnees$Taille,y=donnees$Perf)
coef_cor_R
coef_cor_R<-cor(x=donnees$Taille,y=donnees$Perf,method="Pearson")
coef_cor_R<-cor(x=donnees$Taille,y=donnees$Perf,method="pearson")
coef_cor_R
t = coef_cor_R / sqrt((1-coef_cor_R^2)/(N-2))
t
N
test<-cor.test(x=donnees$Taille,y=donnees$Perf)
test
test<-cor.test(x=donnees$Taille,y=donnees$Perf)
test
reg<-lm(donnees$Perf~donnees$Taille)
summary(reg)
y = reg$coefficients[2] * x +  reg$coefficients[1]
resultat <- 2.93* 2 - 3.59
resultat
X=cbind(c(1,1,1,1),c(15,28,20,10),c(2,4,4,2))
X
Y=c(2.1,3,1.6,1.2)
solve(t(X)%*%X)%*%t(X)%*%Y
0.01/2
1-0.005
y=c(2.1,3,1.6,1.2)
X=C(15,28,20,10)
X<6C(15,28,20,10)
X<-C(15,28,20,10)
x<-c(15,28,20,10)
x
y
sum((y-x%*%0.18)^2)
sum((y-x*0.18)^2)
X<-cbind(c(1,1,1,1),c(15,28,20,10),c(2,4,4,2))
sum((y-X%*%0.18)^2)
sum((y-X%*%betaC)^2)
betaC<-solve(t(X)%*%X)%*%t(X)%*%Y
betaC<-solve(t(X)%*%X)%*%t(X)%*%y
betaC
y-X%*%betaC
(y-X%*%betaC)^2
sum((y-X%*%betaC)^2)
sigma2c<-sum((y-X%*%betaC)^2)
sigma2c
sqrt(sigma2c*solve(t(X)%*%X))
sqrt(sigma2c%*%solve(t(X)%*%X))
solve(t(X)%*%X)
solve(t(X)%*%X)[2,2]
solve(t(X)%*%X)[2,2]*sqrt(sigma2c)
0.18/(solve(t(X)%*%X)[2,2]*sqrt(sigma2c)
0.18/(solve(t(X)%*%X)[2,2]*sqrt(sigma2c))
x1<-c(1,1,1,1)
x2<-c(15,28,20,10)
x3<-c(2,4,4,2)
lm(y~x1+x2+x3)
summary(lm(y~x1+x2+x3))
0.18/sqrt((solve(t(X)%*%X)[2,2]*sigma2c)
sqrt(solve(t(X)%*%X)[2,2])
sqrt(sigma2c)
sigma2c
solve(t(X)%*%X)
0.18/sqrt(0.0002247*0.02247)
summary(lm(y~x2+x3))
sigma2c<-sum((y-X%*%betaC)^2)
sigma2c
solve(t(X)%*%X)
X
ec<-solve(t(X)%*%X)[2,2]
sigma2c
sqrt(sigma2c*ec)
0.18/sqrt(sigma2c*ec)
qt(0.995,1)
betaC
betaC<-betaC[2]
betaC
betaC/sqrt(sigma2c*ec)
0.05/2
1-0.025
0.038-2.776*0.0058
0.038+2.776*0.0058
0.83-2.776*0.154
0.83+2.776*0.154
2.32^2*4
path<-"F:/MIASHS/UEs/regression_lin/ozone.csv"
donnees <- read.table(path,sep=",",dec=",",header=T)
head(donnees)
donnees <- read.table(path,sep=";",dec=",",header=T)
head(donnees)
colnames(donnees)
mod<-lm(maxO3 ~maxo3v +T9 +T12 +Vx12 +Ne12 +Ne15)
mod<-lm(maxO3 ~maxo3v +T9 +T12 +Vx12 +Ne12 +Ne15,data=donnees)
mod<-lm(maxO3 ~ maxO3v +T9 +T12 +Vx12 +Ne12 +Ne15,data=donnees)
summary(mod)
mod$coefficients
s.matrix(mod$coefficients)
as.matrix(mod$coefficients)
residus <- mod$residuals
residus
plot(mod)
head(donneees)
head(donnees)
X<-donnees[,c("maxO3v","T9","T12","Vx12","Ne12","Ne15")]
X
X<-as.matrix(X)
X
H<-X%*%solve(t(X)%*%X)%*%t(X)
H
y<-donnees$maxO3
plot(residus~y)
head(X)
plot(mod)
for(i in 1:6)
{
plot(residus~donnees[,i],xlab=colnames(X)[i])
}
24*2
24*2*31
path<-"F:/MIASHS/TER/Vegeta/Anaelle/data/data_pour_model.csv"
donnees <- read.table(path,sep=",",dec=",",header=T)
head(donnees)
summary(donnees)
setwd("F:/MIASHS/TER/Vegeta/Anaelle")
# Transforme tout en numerique
for (i in 4:ncol(donnees)){
donnees[,i]<-as.numeric(as.character(donnees[,i]))}
?apply
i= unique(donnees$heure_solaire)[1]
i
i= levels(donnees$heure_solaire)[1]
i
apply(donnees[donnees$heure_solaire==i,-c(1:4)],margin=2,fun=mean)
apply(donnees[donnees$heure_solaire==i,-c(1:4)],margin=2,FUN=mean)
apply(donnees[donnees$heure_solaire==i,-c(1:4)],MARGIN=2,FUN=mean)
apply(donnees[donnees$heure_solaire==i,-c(1:4)],MARGIN=2,FUN=mean,na.rm=TRUE)
var_heure<-data.frame()
for (i in levels(donnees$heure_solaire)){
vec<-apply(donnees[donnees$heure_solaire==i,-c(1:4)],MARGIN=2,FUN=mean,na.rm=TRUE)
var_heure<-cbind(var_heure,vec)
}
var_heure
var_heure<-NULL
for (i in levels(donnees$heure_solaire)){
vec<-apply(donnees[donnees$heure_solaire==i,-c(1:4)],MARGIN=2,FUN=mean,na.rm=TRUE)
var_heure<-cbind(var_heure,vec)
}
var_heure
colnames(var_heure)<-levels(donnees$heure_solaire)
var_heure
mod<-lm(data=donnees,SAP_FLOW~NETRAD_1havant +PPFD_IN_1havant + RH +SW_IN_1havant +TA +FC_1havant +H_1havant+LE+VPD+SB+G)
summary(mod)
?predict
?predict.lm
predict.lm(mod,newdata=var_heure)
var_heure
predict.lm(mod,newdata=as.data.frame(var_heure))
data.frame(x = seq(-3, 3, 0.5))
predict.lm(mod,newdata=var_heure[,1])
var_heure[,1]
> newdata = data.frame(Air.Flow=72,  # wrap the parameters
+     Water.Temp=20,
+     Acid.Conc.=85)
newdata = data.frame(Air.Flow=72,  # wrap the parameters
+     Water.Temp=20,
+     Acid.Conc.=85)
newdata = data.frame(Air.Flow=72,    Water.Temp=20,  Acid.Conc.=85)
newdata
t(var_heure)
predict.lm(mod,newdata=t(var_heure))
predict.lm(mod,newdata=as.data.frame(t(var_heure)))
plot(predict.lm(mod,newdata=as.data.frame(t(var_heure))))
plot(predict.lm(mod,newdata=as.data.frame(t(var_heure)))~levels(donnees$heure_solaire),ylab="y predits",xlab="Heures")
levels(donnees$heure_solaire)
as.numeric(levels(donnees$heure_solaire))
plot(predict.lm(mod,newdata=as.data.frame(t(var_heure)))~range(0,23.50,0.50),ylab="y predits",xlab="Heures")
range(0,23.50,0.50)
?range
?list
seq(0,23.50,0.50)
plot(predict.lm(mod,newdata=as.data.frame(t(var_heure)))~seq(0,23.50,0.50),ylab="y predits",xlab="Heures")
plot(predict.lm(mod,newdata=as.data.frame(t(var_heure)))~seq(0,23.50,0.50),ylab="y predits",xlab="Heures",type="l",col="darkgreen")
plot(predict.lm(mod,newdata=as.data.frame(t(var_heure)))~seq(0,23.50,0.50),ylab="Flux de sève predit",xlab="Heures",type="l",col="darkgreen")
summary(mod)
donnees_jour<-donnees[donnees$NETRAD_1havant>0,]
donnees_nuit<-donnees[donnees$NETRAD_1havant<0,]
mod_jour<-lm(data=donnees_jour,SAP_FLOW~NETRAD_1havant +PPFD_IN_1havant + RH +SW_IN_1havant +TA +FC_1havant +H_1havant+LE+VPD+SB+G)
summary(mod_jour)
mod_nuit<-lm(data=donnees_nuit,SAP_FLOW~NETRAD_1havant +PPFD_IN_1havant + RH +SW_IN_1havant +TA +FC_1havant +H_1havant+LE+VPD+SB+G)
summary(mod_nuit)
summary(mod)
mod$coefficients
mod$coefficients[1]
equation_modele_global <- paste("Flux de sève = ",mod$coefficients[1]," + ",mod$coefficients[2]," NETRAD_1havant + ",mod$coefficients[3]," PPFD_IN_1havant + ",
mod$coefficients[4]," RH + ",mod$coefficients[5],"SW_IN_1havant + ",mod$coefficients[6]," TA + ",mod$coefficients[7]," FC_1havant + ",
mod$coefficients[8]," H_1havant + ",mod$coefficients[9]," LE + ",mod$coefficients[10]," VPD + ",mod$coefficients[11]," SB + ",mod$coefficients[12]," G")
equation_modele_global
plot(predict.lm(mod,newdata=as.data.frame(t(var_heure)))~seq(0,23.50,0.50),ylab="Flux de sève predit",xlab="Heure solaire",type="l",col="darkgreen")
coef<-round(mod$coefficients,2)
coef
equation_modele_global <- paste("Flux de sève = ",coef[1]," + ",coef[2]," NETRAD_1havant + ",coef[3]," PPFD_IN_1havant + ",
coef[4]," RH + ",coef[5],"SW_IN_1havant + ",coef[6]," TA + ",coef[7]," FC_1havant + ",
coef[8]," H_1havant + ",coef[9]," LE + ",coef[10]," VPD + ",coef[11]," SB + ",coef[12]," G")
equation_modele_global
var_heure
write.csv(var_heure,"X_par_heure")
write.csv(var_heure,"X_par_heure.csv")
equation_modele_global
coef<-round(mod$coefficients,4)
equation_modele_global <- paste("Flux de sève = ",coef[1]," + ",coef[2]," NETRAD_1havant + ",coef[3]," PPFD_IN_1havant + ",
coef[4]," RH + ",coef[5],"SW_IN_1havant + ",coef[6]," TA + ",coef[7]," FC_1havant + ",
coef[8]," H_1havant + ",coef[9]," LE + ",coef[10]," VPD + ",coef[11]," SB + ",coef[12]," G")
equation_modele_global
